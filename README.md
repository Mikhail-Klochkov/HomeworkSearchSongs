# HomeworkSearchSongs
 Решил в качестве данных взять базу данных песен Songs Lyric.  Ссылка: https://www.kaggle.com/neisse/scrapped-lyrics-from-6-genres Там достаточно много информации помимо текста песни и названия. Есть ещё автор песни, популярность, Жанр.   В начале запуска сервера по сути создаю базу данных (class Document), которая содержит в качестве своих полей вышеперечисленные признаки.  Также мы производим всю необходимую переподготовку текста для анализа запросов  в файле utils.py. Также мы строим инвертированные индексы термов как title, так и text, для быстрого доступа к потенциально значимым объектам базы данных песен.  Также, я решил достаточно сильно заморочиться с тем, чтобы пользователь  мог вводить помимо слов контекстуально относящихся к названию или тексту песни также и имя артиста и названия жанра. В функции retrieve в файле search.py производиться первичный отбор документов из базы данных. То есть я также держу словари с именами  артистов и жанров, которые содержат имя и список индексов каждой песни. Далее после анализа первичного запроса по инвертированным индексам, мы выбираем топ 100-200  документов по значению популярности песни.   После этого уже, мы строим score.py. Где уже используем  предварительно загруженное fastvec1м представления слов.  Для пары документ / запрос мы строим их векторное представление в  R^{300}. Для документа мы используем подход, который был предложен в  материалах к домашнему заданию. "" С помощью embedding попробуем представлять  каждый отдельный текст. Как было показано в  материалах к работе, будем строить нечто  средне взвешенное всех представлений слов  входящих в каждый документ с весами, полученными из tfidf для всего корпуса документов. "" tfidf представление мы строим предварительно!  Ну а далее мы строим косинусное расстояние между представлением запроса и самого документа. По сути время выполнения и определяется в основном  расчётом средне взвешенного, что есть просто матричное произведение c vec представления на матрицу tfifd корпуса документов. и потом суммированием представлений слов в запросе. И после уже  расчётом косинусного расстояния между этим векторами.  Время выполнения запроса на корпусе из 100000 документов, при выборе пор-ка 100-200 документов на первой  стадии отбора по инвертированным индексам пор-ка 3-4 сек -  что долго, наверное, это связано с тем, что достаточно много есть ветвлений в  функции retrieve, где я хотел добавить вариативность с точки зрения того, если  пользователь введёт имя исполнителя или жанр + ещё что-то относящееся к песни. 
